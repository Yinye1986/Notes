<!--toc:start-->
- [语句和表达式](#语句和表达式)
- [重影 shadowing](#重影-shadowing)
- [所有权 ownership](#所有权-ownership)
  - [Q&A](#qa)
- [借用 borrowing](#借用-borrowing)
<!--toc:end-->

# 语句和表达式

可以用`{}`封装代码块, 只要有返回值整个块就是一个表达式

```rust
{
    let a: u8 = 0xff; // 语句
    a                 // 表达式
} // 整个块是表达式
```

1. 以 ; 结尾的是语句
2. ~~有返回值的是表达式;~~ 其实语句有返回值; 是单元类型`()`

# 重影 shadowing

```rust
let a = 10;
let a = 5;
```

**变量名**可以被重新使用

# 所有权 ownership

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权被转移给了 s2
// println!("{}", s1
calculate(s2); // s2的所有权转移到了函数中, 并在函数的生命周期结束后释放
fn calculate(s: String) -> () {
    s.len()
} // 函数结束自动释放传入的变量
// 也就是说在下面的代码中无法使用s2, s2内存已经被释放
```

`println!("{}", s1);`编译会报错, 因为`s1`已不再拥有该内存对象

复合数据类型存储在堆上, 这里语句是所有权的转移

```rust
let x = 5;
let y = x;
println!("x: {}, y: {}", x, y);
```

简单数据类型存储在栈, 这里的语句是值的复制

---

以上简单案例可以总结:

1. 变量是内存对象的所有者
2. 一个内存对象只能有一个所有者
3. 当所有者离开作用域范围时, 内存对象会被drop

## Q&A

- Q: 为什么要引入所有权概念?
- A: 为了内存安全的考量, 例如经典的悬空指针问题

# 借用 borrowing

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s); // 不可变引用
    println!("The length of '{}' is {}.", s, len);
    // 释放的只是引用
    // s依旧可在此作用域中使用
}
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

创建引用的行为被称为借用
归还: 作用域结束, 引用得到释放
