<!--toc:start-->
- [变量](#变量)
  - [变量绑定](#变量绑定)
  - [指定类型的变量绑定](#指定类型的变量绑定)
  - [可变变量绑定](#可变变量绑定)
  - [Q&A](#qa)
- [常量](#常量)
<!--toc:end-->

# 变量

## 变量绑定

```rust
let a = 10; // 虽然未显式制定类型, 但会自动根据绑定值确定变量类型
let a = 5;  // 重影机制, 合法, 甚至可以改类型
```

决定类型后, 下面操作被禁止:

| 表达式         |     原因      |
|:---------------|:--------------|
| ~~a = "abc";~~ | a的类型已确定 |
| ~~a = 4.56;~~  | a是i32, 4.56自动强制转换i32会丢失精度, Rust语言不允许精度有损失的自动数据类型转换 |
| ~~a = 456;~~   | a不是mutable的 |

## 指定类型的变量绑定

```rust
// 手动指定变量的类型
let a: i32 = 20;
let b = 30_i32;
let c = 30i32
```

## 可变变量绑定

```rust
let mut a = 30i32;
a = 20;
```

mutable: 可变的

## Q&A
- Q: 为什么要有不可变变量?
- A: 一个变量往往被多处代码所使用;
   其中一部分代码假定该变量的值永远不会改变, 而另外一部分代码却无情的改变了这个值;
   在实际开发过程中，这个错误是很难被发现的，特别是在多线程编程中。
   (我的理解: 牺牲一定自由度换来更多的安全性~~或许还能节省一定资源?~~)

# 常量

```rust
const AA: i32 = 123_000_000;
const BB: u32 = 123000000;
```

命名规范: 全大写, 下划线分割
支持: 可在数字字面量插入下划线提高可读性


1. 始终不可变
2. 不支持重影
3. 一定要手动指定类型
4. 生命周期: 'static
