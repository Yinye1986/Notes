# 静态库 (Static Libraries)

- 扩展名: 通常是`.a`; 例如`libmath.a`
- 结  构: 静态库本质上是一组`.o`目标文件的归档文件, 里面装满了未链接的机器代码片段
- 链接时机: 编译/链接时
- 内存使用: 每个运行的进程都在内存中有库代码的独立副本
- 运行时依赖: 无
- 更新与维护: 库更新后，所有依赖程序必须重新编译才能使用新版本
- 部署难度: 容易(只需分发一个可执行文件)
- PIC: 否

### 生成静态库

```shell
# 编译 moduleA.cpp 为 PIC 目标文件
g++ -c -fPIC src/modbusTCP.cpp -I inc -o modbusTCP.o
ar rcs libmylib.a modbusTCP.o
```

### 使用静态库

```shell
# 有mylib后不需要modbusTCP.cpp了, 但还需要.hpp
g++ src/example.cpp -I inc -L . -lmylib -o exe
# 编译后可独立运行
```

# 动态库/共享库 (Dynamic/Shared Libraries)

- 扩展名: 在Linux中通常是`.so`; 比如`libmath.so`代表 Shared Object
- 结  构： 动态库是已经编译和汇编好的机器代码, 但它的地址是相对的(位置无关代码, PIC), 需要运行时确定
- 链接时机: 运行时
- 内存使用: 多个运行的进程共享内存中的同一份库代码，节省系统内存
- 运行时依赖: 强
- 更新与维护: 库更新后, 只需替换系统中的`.so`文件, 所有程序自动使用新版本
- 部署难度: 较难(必须确保目标系统具有或能找到所有`.so`依赖项)
- PIC: 是

### 生成动态库

```shell
g++ -shared -o libmylib.so modbusTCP.o
```

### 使用动态库

```shell
# 有mylib后不需要modbusTCP.cpp了, 但还需要.hpp
g++ src/example.cpp -I inc -L . -lmylib -o exe
# 编译后不能单独运行
```

# 不同操作系统的库

|操作系统/平台|静态库|动态库|
|:------------|:-----|:-----|
|windows      |.LIB  |.DLL  |
|macOS/iOS    |.a    |.dylib & .framework|
|Android      |.a    |.so   |
