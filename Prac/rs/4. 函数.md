<!--toc:start-->
- [函数](#函数)
  - [形式参数](#形式参数)
  - [返回](#返回)
- [永不返回的发散函数](#永不返回的发散函数)
<!--toc:end-->

# 函数

一个函数所有的东西:

```rust
fn add(i: i32, j: i32) -> i32 {
    i + j
}
```

![函数的组成示意图](https://github.com/Yinye1986/Notes/tree/main/Prac/rs/assets/4-1.jpg)

## 形式参数

函数的形式参数一定要标注类型

## 返回

函数执行完返回, 也可用`return`提前返回

```rust
fn plus_or_minus(x:i32) -> i32 {
    if x > 5 {
        return x - 5 // 使用return+表达式可以直接返回
    }

    x + 5 // 正常返回
}
```

Rust 是静态类型语言, 有极其严格的静态类型系统, 返回值必须严格匹配返回类型

tips: 以语句结尾其实隐式返回`()`

# 永不返回的发散函数

空代码块返回(), 而非!, 于是会报错类型不匹配, 编译不通过

```rust
fn dead_end() -> ! {
}
```

像下面这样改, 可以通过编译

```rust
fn dead_end_ok() -> ! {
    panic!("致命错误！");
}

fn dead_end_loop() -> ! {
    loop {
        // 永远不退出
    }
}

use std::process;

fn dead_end_exit() -> ! {
    process::exit(1); // 立即退出进程
}
```

着重讲讲`panic!("tips");`

Rust 会启动错误处理机制

- 栈展开(Unwinding): 程序会沿着调用堆栈向后回溯, 依次执行所有在 dead_end_ok() 函数以及其调用链上创建的局部变量的析构函数(Drop)
  - 目的: 这是 Rust 安全性的关键。它确保所有占用的资源(如堆内存, 文件句柄, 网络连接等)都能被安全地释放和清理, 以避免内存泄漏
- 中  止(Abort): 如果你在 Cargo.toml 中配置了 panic = 'abort', 那么程序会跳过清理步骤, 直接要求操作系统终止整个进程
