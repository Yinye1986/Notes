# 基本类型

## 整型

| 长度 | 有符号类型 | 无符号类型 |
| :--- | :--- | :--- |
| 8 位 | `i8` | `u8` |
| 16 位 | `i16` | `u16` |
| 32 位 | `i32` | `u32` |
| 64 位 | `i64` | `u64` |
| 128 位 | `i128` | `u128` |
| 视架构而定 | `isize` | `usize` |

---

字面量的写法

| 数字字面量 | 示例 |
| :--- | :--- |
| 十进制 | `98_222` |
| 十六进制 | `0xff` |
| 八进制 | `0o77` |
| 二进制 | `0b1111_0000` |
| 字节 (仅限于 `u8`) | `b'A'` |

## 浮点型

```rust
fn main() {
    let x = 2.0; // 默认使用f64
    let y: f32 = 3.0;
}
```

浮点数根据 IEEE-754 标准实现; f32 类型是单精度浮点型，f64 为双精度

分别为 32 位和 64 位大小; 默认浮点类型是 f64, 在现代的 CPU 中它的速度与 f32 几乎相同, 但精度更高

---

浮点数陷阱

浮点数由于底层格式的特殊性, 导致了如果在使用浮点数时不够谨慎, 就可能造成危险, 有两个原因:

1. 浮点数往往是你想要数字的近似表达 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 0.1 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
2.  浮点数在某些特性上是反直觉的 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 >，>= 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 f32 ， f64 上的比较运算实现的是 std::cmp::PartialEq 特征(类似其他语言的接口)，但是并没有实现 std::cmp::Eq 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：

举个例子:

Rust 的 HashMap 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 K 没有特定类型的限制，但是要求能用作 K 的类型必须实现了 std::cmp::Eq 特征，因此这意味着你无法使用浮点数作为 HashMap 的 Key，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 HashMap 的 Key。

为了避免上面说的两个陷阱, 你需要遵守以下准则:

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心
