# 引用 reference

一种指向某值地址但不拥有该值的数据类型(指针)

## 不可变引用

```rust
let a = 114514;
let ptr = &a;
println!("a的值：{}", *ptr);
// println!("a的地址：{}", ptr); 错误: Rust 的语法糖会自动解引用
println!("a的地址：{:p}", ptr); // 正确: 需要指定占位符才行
// *ptr = 114514 错误: 不可变引用手动解引用也无法改变值
```

不可变引用可以有任意数量

## 可变引用

```rust
let a = 114514;
// let ptr = &mut a; 错误: 不可变变量无法创建可变引用
let mut a = 114514;
let ptr = &mut a;
// let ptr2 = &mut a; 错误: 同一个变量只能同时存在一个可变引用

```

最多只能拥有一个可变引用

### 关于上面提到的语法糖

```rust
let mut s: String = "Hello".to_string();
let ptr = &mut s;
s.push_str("World");
println!("{}\n", s);
```
```rust
let mut s: String = "HelloWorld".to_string();
let ptr = &mut s;
ptr.push('!');
println!("{}", s);
```

注意到关键点ptr是个指针为什么能使用变量的方法`push()`

其实也是自动解引用了这里其实编译时会处理为`*ptr.push()`

实际流程:
1. 直接查找: 先检查本身的类型有没有叫push的方法
2. 自动解引用
3. 再次查找: 在解引用后检查有没有叫push的方法
