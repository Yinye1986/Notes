# 切片 Slice

切片是引用! 存在栈上

## 引子

下面的代码中 s 是字符串(String)类型, 而 b 是切片类型(&str)

展示了通过字符串创建切片

```rust
let s = String::from("hello world"); // s 是String类型
let b = "Hello, world!";             // b 是&str类型
// let b: &str = "Hello, world!";
let hello = &s[0..5]; // 通过字符串创建切片
let world = &s[6..11]; // 左闭右开
```

## 切片的内部组成

![图例](https://github.com/Yinye1986/Notes/tree/main/Prac/rs/assets/2.2-1.jpg)

切片由一个指针和一个长度变量组成

图例展示该切片的指针指向 s 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节), 且该切片的长度是 5 个字节(终止索引-开始索引)

### 切片的本质

切片是对集合类型的部分引用

## 涉及到UTF-8字符的切片

```rust
let s = "中国人";
let a = &s[0..2];
println!("{}",a);
```

这个示例是错的; UTF-8中, 一个汉字占3个字节, 切片一定要切到字符的边界

## 语法糖

```rust
let s = String::from("hello");
let slice = &s[0..2];
let slice = &s[..2]; // 从0开始可省略0
```

```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[4..len]; // 末位字节索引..字符串长度
let slice = &s[4..]; // 末位字节索引..
```

```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[0..len]; // 取全部字节
let slice = &s[..]; // 取全部字节
```

取全部字节

### 其他切片

其他集合类型也有切片, 例如数组切片

在此补充其他类型切片及其标识符:

...

# 字符串

底层使用u8存储UTF-8编码

# 元组 Tuple

元组是由多种类型组合到一起形成的, 因此它是复合类型, 元组的长度是固定的, 元组中元素的顺序也是固定的

## 创建元组

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

## 访问元组

### 方法一: 使用模式匹配结构元组

```rust
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
}
```

### 方法二: 使用`.`操作符来获取元组中的值

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let one = x.0;
    println!("{}", x.1) // 下标从0开始
}
```

## 使用元组返回多个值
```rust
fn main() {
    let s1 = String::from("hello");
    let (s2, len) = calculate_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}

```

## Tips

看了以上案例易得:
元组长这样: `(s, length)`
元组的标识符长这样: `(String, usize)`

# 结构体

## 引子

在其他语言中, 可以用结构体来声明一个三维空间中的点, 例如 Point(10, 20, 30), 虽然使用 Rust 元组也可以做到: `(10, 20, 30)`, 但是这样写有个非常重大的缺陷: 不具备任何清晰的含义;

元组结构体, 可以解决这个问题

结构体可以帮我们更好地抽象问题

## 组成

一个结构体由几部分组成:
  - 通过关键字 struct 定义
  - 一个清晰明确的结构体名称
  - 几个有名字的结构体字段

展示一段伪代码解释组成:
```
struct 结构体名称{
  <字段>,
  字段名: 字段类型,
  <字段>,
  ...
}
```

## 结构体的创建

```Rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

## 结构体的实例化

初始化实例时, 每个字段都要初始化

初始化时的字段顺序不需要和结构体定义时的顺序一致

```rust
let mut user1 = User { // 声明可变实例
    active: true,
    username: String::from("someusername123"),
    email: String::from("someone@example.com"),
    sign_in_count: 1,
};
```

## 结构体的访问

需要注意的是, 要使结构体实例某个字段可变, 这是不支持单独设置的, 需要在实例化时声明为可变的

```rust
user1.email = String::from("anotheremail@example.com");
```

## 自己写结构体的构造函数

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

函数会返回一个结构体实例

### 语法糖

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email, // 这两处可以简写
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

## 结构体实例更新(对其中一两个字段重新赋值)

```rust
let user2 = User {
      active: user1.active,
      username: user1.username,
      email: String::from("another@example.com"),
      sign_in_count: user1.sign_in_count,
  };
```

### 语法糖

```rust
let user2 = User {
    email: String::from("another@example.com"), // 改要改的
    ..user1 // 其他直接这样, 就可以全搬过去
};
```

必须在结尾使用`..user1`

## 结构体实例更新中的重要提示

注意到`username`的赋值其实是所有权转移, 会使实例`user1`的`username`字段无法使用, 但其他仍然可以使用

## 结构体的内存排列
