# Rust 整型选择：`i32` 性能 vs. `u8` 资源

## 核心原则：**原生字长**优化

你提出的观点（`u8` 更省内存）理论上正确，但现代 **CPU 的设计** 和 **内存总线** 是为处理其**原生字长**（通常是 32 位或 64 位）而优化的。因此，使用 **`i32` 往往能带来更高的运行效率**。

---

## 为什么 `i32` 往往性能更优（默认选择）

### 1. CPU 的原生字长优化

* **最快处理：** 现代 CPU（多为 64 位架构）在内部使用 **32 位或 64 位寄存器**进行操作。即使处理 `u8` 数据，CPU 也需要将其加载到 32 位/64 位寄存器中。
* **小类型低效：** 使用 **`u8` 或 `i8`** 时，编译器可能需要生成额外的指令（如 **`masking`** 或 **`sign extension`**）来处理和对齐这些小数据，确保操作不会溢出其位数。这些额外的指令会**增加 CPU 周期**，降低速度。
* **`i32` 是最佳妥协：** 它是跨 32 位和 64 位架构都能保持高性能的通用标准，因此 Rust 编译器将其设为**默认类型**。

### 2. 内存对齐和加载效率

* **高效加载：** CPU 访问内存时，通常以 **4 字节（32 位）** 或 **8 字节（64 位）** 为单位进行批量加载。
* **`i32` 的优势：** 32 位（4 字节）数据通常能完美地与 CPU 的加载边界对齐，实现**一次性高效加载**。
* **`u8` 的劣势：** 即使 `u8` 只占用 1 字节，CPU 可能仍然需要读取一个 4 字节的块，然后执行额外操作提取所需的 1 字节，这抵消了存储上的节省。

---

## 使用准则总结：性能与资源的权衡

| 目标 | 优先类型 | 理由 / 场景 |
| :--- | :--- | :--- |
| **通用性能** | **`i32`** (Rust 默认) | **最快 CPU 运算速度**。适用于局部变量、简单计数器、函数内计算。 |
| **内存节省** | **`u8` / `u16`** | **存储内存**敏感的大型集合。例如：处理图像（RGB 数据）、需要与硬件或网络协议严格匹配尺寸时。 |
| **集合索引** | **`usize` / `isize`** | 必须用于数组或集合的**索引**和**长度**计算，以确保与运行程序的架构（32/64 位）兼容。 |

**核心结论：** `i32` 默认和推荐是基于“**牺牲一点内存，换取更快的指令执行速度**”的工程权衡，这最大限度地利用了现代 CPU 的架构设计。
