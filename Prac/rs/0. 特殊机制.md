# 重影 shadowing

```rust
let a = 10;
let a = 5;
```

**变量名**可以被重新使用

# 所有权 ownership

内存对象是有主人的, 变量绑定把内存对象绑定一个变量, 变量就是所谓主人, 变量只能有一个主人

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权被转移给了 s2
```

~~println!("{}", s1);~~ 此处编译会报错, 因为 s1 已不再拥有该值

为什么会这样?
复杂数据类型String, Vec存储在堆上, 此时的操作是所有权的move
为什么要引入所有权概念?
...

```rust
let x = 5;
let y = x;
println!("x: {}, y: {}", x, y);
```
简单数据类型存储在栈, 此时的操作是值的copy

# 借用 borrowing

创建引用(reference)的行为被称为借用

引用: 一种指向某值地址但不拥有该值的数据类型(指针)

归还: 作用域结束, 引用得到释放

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s); // 不可变引用
    println!("The length of '{}' is {}.", s, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

规则:
- 不可变引用 (&): 可以拥有任意数量的不可变引用
- 可变引用(&mut): 最多只能拥有一个可变引用
