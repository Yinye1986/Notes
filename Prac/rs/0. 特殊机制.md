# 语句和表达式

```rust
{
    let a: u8 = 0xff; // 语句
    a                 // 表达式
} // 整个块是表达式
```

可以用{}封装代码块, 只要有返回值整个块就是一个表达式

---

1. 以 ; 结尾的是语句
2. 有返回值的是表达式

# 重影 shadowing

```rust
let a = 10;
let a = 5;
```

**变量名**可以被重新使用

# 所有权 ownership

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 的所有权被转移给了 s2
calculate(s2); // s2的所有权转移到了函数中, 并在函数的生命周期结束后释放
fn calculate(s: String) -> () {
    s.len()
} // 函数结束自动释放传入的变量
// 也就是说在下面的代码中无法使用s2, s2内存已经被释放
```

~~println!("{}", s1);~~ 此处编译会报错, 因为 s1 已不再拥有该值

复合数据类型存储在堆上, 这里语句是所有权的转移

```rust
let x = 5;
let y = x;
println!("x: {}, y: {}", x, y);
```

简单数据类型存储在栈, 这里的语句是值的copy

---

以上简单案例可以总结:

1. 变量是内存对象的所有者
2. 一个内存对象只能有一个所有者
3. 当所有者离开作用域范围时, 内存对象会被drop

## Q&A
- Q: 为什么要引入所有权概念?
- A: 为了内存安全的考量, 例如经典的悬空指针问题
- Q:

# 借用 borrowing

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s); // 不可变引用
    println!("The length of '{}' is {}.", s, len);
    // 释放的只是引用
    // s依旧可在此作用域中使用
}
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

创建引用的行为被称为借用
归还: 作用域结束, 引用得到释放

---

1. 不可变变量无法创建可变引用
2. 不可变引用手动解引用依旧无法改变值
3. 有了可变引用就不能有不可变引用
