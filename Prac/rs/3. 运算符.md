# 数字运算

只有同种类型才能进行运算

```rust
fn main() {
    let sum = 5 + 10;
    let difference = 95.5 - 4.3;
    let product = 4 * 30;
    let quotient = 56.7 / 32.2;
    let remainder = 43 % 5;
}
```

# 位运算

|    |      |                               |
|:---|:-----|:------------------------------|
| &  | 位与	| 相同位置均为1时则为1, 否则为0 |
| |  | 位或	| 相同位置只要有1时则为1, 否则为0 |
| ^  | 异或	| 相同位置不相同则为1, 相同则为0 |
| !  | 位非	| 把位中的0和1相互取反, 即0置为1，1置为0 |
| << | 左移	| 所有位向左移动指定位数, 右位补0 |
| >> | 右移	| 所有位向右移动指定位数, 带符号移动(正数补0，负数补1)|

除了`!=`都支持类似`+=`的语法糖(因为要作为不等于判断使用)

---

```rust
fn main() {
   let a: u8 = 255;
   let b = a>>7; // ok
   let b = a<<7; // ok
   let b = a>>8; // overflow
   let b = a<<8; // overflow
}
```

对于移位运算, Rust 会检查它是否超出该整型的位数范围，如果超出，则会报错 overflow;

8位整型若移位 8 位, 就会报错, 但如果移位 7 位就不会;

Rust 这样做的理由也很简单, 如果移位太多, 那么这个移位后的数字就是全 0 或者全 1(例如上面255右移八位直接变成全0);

所以移位操作不如直接写 0 或者 -1, 这很可能意味着这里的代码是有问题的;

需要注意的是, 不论 debug 模式还是 release 模式, Rust 都会检查溢出

# 序列 Range

Rust 提供序列来生成连续的数值(数字或字符(Unicode字符集); Q: Why? A: 只有这些是连续的)
