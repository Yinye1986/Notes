# NEC

发送: 同步码头 地址码 反地址码 控制码 反控制码

并且在发送其中每个字段时, 先发送低位, 再高位

# 位序颠倒算法

发送: 0x29
- T: 00101001 先发送0
- R: 10010100 先收到0

位序颠倒处理的详细过程:

方法一:

```c
uint8_t data = 0;

data=data|(1 << 0);
data |=   (0 << 1);
data |=   (0 << 2);
data |=   (1 << 3);
data |=   (0 << 4);
data |=   (1 << 5);
data |=   (0 << 6);
data |=   (0 << 7);
printf("%h", data); // 输出0x29
```

方法二:

提前算好所有的位序反转后的值, 查表

方法三:

```c
uint8_t reverse_bits(uint8_t x) {
    x = (x & 0xF0) >> 4 | (x & 0x0F) << 4; // 高四位和第四位交换
    x = (x & 0xCC) >> 2 | (x & 0x33) << 2; // 每四位中高二位和低二位交换
    x = (x & 0xAA) >> 1 | (x & 0x55) << 1; // 每二位中高位和低位反转
    return x;
}
```

方法四:

ARM Cortex-M 特殊指令

RBIT 指令(Reverse Bits), 但仅对32位有效

```c
```

# 具体实现

利用方法一实现

```c
// 1. 检测到同步码头
// 2. 还原地址码
uint8_t addr=0;
uint8_t recv = 0b10010100; // 接收的源
for (uint8_t i = 0; i<8; i++) {
    uint8_t bit = ((recv >> (7-i)) & 1);
    addr |= (bit << i);
}
// 3. 还原反地址码
// 4. 验证
// 5. 还原控制码
// 6. 还原反控制码
// 7. 验证
```

# 实际编程

推荐方式接收一位处理一位

验证还原全都封装到函数中; 只需要关注链路层的数据: 地址和命令
