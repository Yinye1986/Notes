<!--toc:start-->
- [整型](#整型)
  - [字面量的写法](#字面量的写法)
- [浮点型](#浮点型)
- [NaN](#nan)
- [字符](#字符)
- [布尔](#布尔)
- [单元类型(unit)](#单元类型unit)
- [有理数和复数](#有理数和复数)
<!--toc:end-->

# 整型

|        |       |    |
|:-------|:------|:---|
| 8 位   | i8    | u8 |
| 16 位  | i16   | u16 |
| 32 位  | i32   | u32 |
| 64 位  | i64   | u64 |
| 128 位 | i128  | u128 |
| arch   | isize | usize |

## 字面量的写法

- DEC: 98_222
- HEX: 0xff
- OCT: 0o77
- BIN 0b1111_0000

特殊的, 对于`u8`类型可以以`b'A'`的形式存储ASCII字符集中的字符

# 浮点型

浮点数根据 IEEE-754 标准实现; `f32`类型是单精度浮点型, `f64`为双精度

分别为 32 位和 64 位大小; 默认浮点类型是`f64`, 在现代的 CPU 中它的速度与`f32`几乎相同, 但精度更高

```rust
fn main() {
    let x = 2.0; // 默认使用f64
    let y: f32 = 3.0;
}
```

# NaN

若表达式的值无数学意义, 会自动变成`NaN`

所有和`NaN`的交互, 都会返回`NaN`

```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x); // NaN不能比较, 代码会崩溃
}
```

```rust
fn main() {
    let x = (-42.0_f32).sqrt(); // 返回NaN
    if x.is_nan() { // 可以通过is_nan()来防御性编程
        println!("未定义的数学行为");
    }
}
```

# 字符

Rust 字符类型支持的字符集是 Unicode, Unicode 是4字节编码, 因此`char`的占用也是4字节(32位)

```rust
let a: char = '🦀'; // 字符只能用'', 字符串用""
```

# 布尔

bool 占用 1 字节

```rust
let t: bool = true;
let f = false;
```

# 单元类型(unit)

`()`

```rust
let none: () = ()

fn do_nothing() {
} // 隐式返回 ()

let result = do_nothing();

let x = {
    let a = 1; // 表达式的结果是 ()
    a + 1      // 没有分号，作为块的返回值
};

let y = {
    let b = 1; // 表达式的结果是 ()
    b + 1;     // 有分号，块的返回值是 ()
};

```

# 有理数和复数

需要使用num库
