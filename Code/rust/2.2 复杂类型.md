<!--toc:start-->
- [切片 Slice](#切片-slice)
  - [切片的内部组成](#切片的内部组成)
  - [本质](#本质)
  - [初始化切片](#初始化切片)
  - [涉及到UTF-8字符的切片](#涉及到utf-8字符的切片)
  - [语法糖](#语法糖)
    - [其他切片](#其他切片)
- [字符串](#字符串)
  - [编码](#编码)
- [元组 Tuple](#元组-tuple)
  - [创建元组](#创建元组)
  - [访问元组](#访问元组)
    - [方法一](#方法一)
    - [方法二](#方法二)
  - [使用元组返回多个值](#使用元组返回多个值)
  - [Tips](#tips)
- [结构体](#结构体)
  - [引子](#引子)
  - [组成](#组成)
  - [结构体的创建](#结构体的创建)
  - [结构体的实例化](#结构体的实例化)
  - [结构体的访问](#结构体的访问)
  - [自己写结构体的构造函数](#自己写结构体的构造函数)
    - [语法糖](#语法糖)
  - [结构体实例更新(对其中一两个字段重新赋值)](#结构体实例更新对其中一两个字段重新赋值)
    - [语法糖](#语法糖)
  - [结构体实例更新中的重要提示](#结构体实例更新中的重要提示)
  - [结构体的内存排列](#结构体的内存排列)
  - [单元结构体](#单元结构体)
  - [结构体数据的所有权](#结构体数据的所有权)
  - [打印结构体](#打印结构体)
    - [方法一](#方法一)
    - [方法二](#方法二)
  - [自己实现Display方法](#自己实现display方法)
- [枚举](#枚举)
  - [创建及成员类型的实例化](#创建及成员类型的实例化)
  - [访问](#访问)
  - [枚举和结构体一起使用实现二维属性的抽象](#枚举和结构体一起使用实现二维属性的抽象)
    - [语法糖](#语法糖)
  - [枚举在工程中的用例](#枚举在工程中的用例)
  - [Option<T>处理空值](#optiont处理空值)
    - [定义](#定义)
    - [变量绑定](#变量绑定)
    - [为什么要引入这套概念来处理空值](#为什么要引入这套概念来处理空值)
    - [Some(T)怎么参与运算](#somet怎么参与运算)
- [数组](#数组)
  - [长度固定的array](#长度固定的array)
    - [访问数组](#访问数组)
    - [批量初始化所有权类型数组](#批量初始化所有权类型数组)
    - [数组切片](#数组切片)
  - [动态数组](#动态数组)
    - [创建](#创建)
    - [增删](#增删)
    - [访问](#访问)
<!--toc:end-->

# 切片 Slice

## 切片的内部组成

![图例](https://github.com/Yinye1986/Notes/tree/main/Prac/rs/assets/2.2-1.jpg)

切片由一个指针和一个长度变量组成(胖指针)

图例展示该切片的指针指向 s 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节), 且该切片的长度是 5 个字节(终止索引-开始索引)

## 本质

**切片是引用** 存在栈上

注意, &str不需要解引用才能表示字面量, 而且也不能被解引用, 因为是胖指针, 指向的是一个动态大小类型

## 初始化切片

下面的代码中 s 是字符串(String)类型, 而 b 是切片类型(&str)

展示了通过字符串创建切片

```rust
let s = String::from("hello world"); // s 是String类型
let b = "Hello, world!";             // b 是&str类型
// let b: &str = "Hello, world!";
let hello = &s[0..5]; // 通过字符串创建切片
let world = &s[6..11]; // 左闭右开
```

## 涉及到UTF-8字符的切片

```rust
let s = "中国人";
let a = &s[0..2];
println!("{}",a);
```

这个示例是错的; UTF-8中, 一个汉字占3个字节, 切片一定要切到字符的边界

## 语法糖

```rust
let s = String::from("hello");
let slice = &s[0..2];
let slice = &s[..2]; // 从0开始可省略0
```

```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[4..len]; // 末位字节索引..字符串长度
let slice = &s[4..]; // 末位字节索引..
```

```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[0..len]; // 取全部字节
let slice = &s[..]; // 取全部字节
```

取全部字节

### 其他切片

其他集合类型也有切片, 例如数组切片

在此补充其他类型切片及其标识符:

...

# 字符串

## 编码

UTF-8 编码(占用字节1-4不等), 所以在Rust中字符串的占用也是随着不同 UTF-8 字符而变化

底层使用u8存储UTF-8编码

# 元组 Tuple

元组是由多种类型组合到一起形成的, 因此它是复合类型, 元组的长度是固定的, 元组中元素的顺序也是固定的

## 创建元组

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

## 访问元组

### 方法一

使用模式匹配结构元组

```rust
fn main() {
    let tup = (500, 6.4, 1);
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);
}
```

### 方法二

使用`.`操作符来获取元组中的值

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let one = x.0;
    println!("{}", x.1) // 下标从0开始
}
```

## 使用元组返回多个值
```rust
fn main() {
    let s1 = String::from("hello");
    let (s2, len) = calculate_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();
    (s, length)
}

```

## Tips

看了以上案例易得:
元组长这样: `(s, length)`
元组的标识符长这样: `(String, usize)`

# 结构体

## 引子

在其他语言中, 可以用结构体来声明一个三维空间中的点, 例如 Point(10, 20, 30), 虽然使用 Rust 元组也可以做到: `(10, 20, 30)`, 但是这样写有个非常重大的缺陷: 不具备任何清晰的含义;

元组结构体, 可以解决这个问题

结构体可以帮我们更好地抽象问题

## 组成

一个结构体由几部分组成:
  - 通过关键字 struct 定义
  - 一个清晰明确的结构体名称
  - 几个有名字的结构体字段

展示一段伪代码解释组成:
```
struct 结构体名称{
  <字段>,
  字段名: 字段类型,
  <字段>,
  ...
}
```

## 结构体的创建

```Rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

## 结构体的实例化

初始化实例时, 每个字段都要初始化

初始化时的字段顺序不需要和结构体定义时的顺序一致

```rust
let mut user1 = User { // 声明可变实例
    active: true,
    username: String::from("someusername123"),
    email: String::from("someone@example.com"),
    sign_in_count: 1,
};
```

## 结构体的访问

需要注意的是, 要使结构体实例某个字段可变, 这是不支持单独设置的, 需要在实例化时声明为可变的

```rust
user1.email = String::from("anotheremail@example.com");
```

## 自己写结构体的构造函数

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```

函数会返回一个结构体实例

### 语法糖

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email, // 这两处可以简写
        username,
        active: true,
        sign_in_count: 1,
    }
}
```

## 结构体实例更新(对其中一两个字段重新赋值)

```rust
let user2 = User {
      active: user1.active,
      username: user1.username,
      email: String::from("another@example.com"),
      sign_in_count: user1.sign_in_count,
  };
```

### 语法糖

```rust
let user2 = User {
    email: String::from("another@example.com"), // 改要改的
    ..user1 // 其他直接这样, 就可以全搬过去
};
```

必须在结尾使用`..user1`

## 结构体实例更新中的重要提示

注意到`username`的赋值其实是所有权转移, 会使实例`user1`的`username`字段无法使用, 但其他仍然可以使用

## 结构体的内存排列

```rust
#[derive(Debug)]
 struct File {
   name: String,
   data: Vec<u8>,
 }

 fn main() {
   let f1 = File {
     name: String::from("f1.txt"),
     data: Vec::new(),
   };

   let f1_name = &f1.name;
   let f1_length = &f1.data.len();

   println!("{:?}", f1);
   println!("{} is {} bytes long", f1_name, f1_length);
 }```

![图例](https://github.com/Yinye1986/Notes/tree/main/Prac/rs/assets/2.2-2.png)

从图中可以清晰地看出 File 结构体两个字段 name 和 data 分别拥有底层两个`u8`数组的所有权, 通过 ptr 指针指向底层数组的内存地址

该图片也侧面印证了: 把结构体中具有所有权的字段转移出去后, 将无法再访问该字段, 但是可以正常访问其它的字段

## 元组结构体 Tuple Struct

如果想要抽象一组数据, 但是又不需要给每个数据设置字段名称, 可以使用元组结构体, 这种结构体长得像元组, 故得名

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

## 单元结构体

```rust
struct AlwaysEqual;
let subject = AlwaysEqual;
// 我们不关心 AlwaysEqual 的字段数据, 只关心它的行为, 因此将它声明为单元结构体, 然后再为它实现某个特征
impl SomeTrait for AlwaysEqual {
}
```

## 结构体数据的所有权

我们希望每个实例有自己的数据而非共用数据, 所以不采用引用类型;

若一定要用引用类型, 需要加上生命周期, 否则编译不通过

```rust
struct User {
    username: &str,
    email: &str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: "someone@example.com",
        username: "someusername123",
        active: true,
        sign_in_count: 1,
    };
}
```

以上代码报错:

```shell
error[E0106]: missing lifetime specifier
 --> src/main.rs:2:15
  |
2 |     username: &str,
  |               ^ expected named lifetime parameter // 需要一个生命周期
  |
help: consider introducing a named lifetime parameter // 考虑像下面的代码这样引入一个生命周期
  |
1 ~ struct User<'a> {
2 ~     username: &'a str,
  |

error[E0106]: missing lifetime specifier
 --> src/main.rs:3:12
  |
3 |     email: &str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 ~ struct User<'a> {
2 |     username: &str,
3 ~     email: &'a str,
  |
```

## 打印结构体

```rust
struct Rectangle {
    width: u32,
    height: u32,
}
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!("rect1 is {}", rect1);
}```

报错:

```shell
error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
```

用`{}`方式输入的类型需要实现`std::fmt::Display`

### 方法一

```rust
#[derive(Debug)] // 需要用derive派生实现Debug
struct Rectanle {
    // ...
}
let rect1 = Rectangle {
    // ...
}

println!("rect1 is {:?}", rect1);
```

用`derive`派生实现`Debug`方法, 并使用`{:?}`或`{:#?}`匹配输出

### 方法二

使用`dbg!`宏

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale),
        height: 50,
    };

    dbg!(&rect1);
}
```

输出:
```shell
$ cargo run
[src/main.rs:10] 30 * scale = 60
[src/main.rs:14] &rect1 = Rectangle {
    width: 60,
    height: 50,
}
```

## 自己实现Display方法

// ...

# 枚举

## 创建及成员类型的实例化

```rust
#[derive(Debug)]
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
} // 创建类型
let heart = PokerSuit::Hearts;
let diamond = PokerSuit::Diamonds; // 创建 PokerSuit 枚举类型的两个成员实例
```

## 访问

```rust
fn main() {
    let heart = PokerSuit::Hearts;
    let diamond = PokerSuit::Diamonds;

    print_suit(heart);
    print_suit(diamond);
}

fn print_suit(args: PokerSuit) {
    // 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug
    println!("{:?}",card);
}
```

有一个反常识的点, `let heart = PokerSuit::Hearts;`

heart虽然是基于枚举体的成员实例化的, 但类型就是`PokerSuit`

例如这个函数，以往的认知看了参数是传入一个枚举体，但实际却不是，这里的args是类型为PokerSuit的枚举，实际上只代表其中一个成员

## 枚举和结构体一起使用实现二维属性的抽象

```rust
enum PokerSuit {
    Clubs,
    Spades,
    Diamonds,
    Hearts,
}

struct PokerCard {
    suit: PokerSuit,
    value: u8
}

fn main() {
   let c1 = PokerCard {
       suit: PokerSuit::Clubs,
       value: 1,
   };
   let c2 = PokerCard {
       suit: PokerSuit::Diamonds,
       value: 12,
   };
}
```

### 语法糖

```rust
enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(char),
}

fn main() {
   let c1 = PokerCard::Spades(5);
   let c2 = PokerCard::Diamonds(13);
   let c3 = PokerCard::Hearts('J');
}
```

另一个示例

```rust
struct Ipv4Addr {
    // --snip--
}
struct Ipv6Addr {
    // --snip--
}
enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

更强大的示例

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}
```

## 枚举在工程中的用例

同一化类型

例如我们有一个 WEB 服务, 需要接受用户的长连接, 假设连接有两种: TcpStream 和 TlsStream, 但是我们希望对这两个连接的处理流程相同, 也就是用同一个函数来处理这两个连接, 代码如下:

```rust
fn new (stream: TcpStream) {
  let mut s = stream;
  if tls {
    s = negotiate_tls(stream)
  }

  // websocket是一个WebSocket<TcpStream>或者
  //   WebSocket<native_tls::TlsStream<TcpStream>>类型
  websocket = WebSocket::from_raw_socket(
    s, ......)
}
```

此时, 枚举类型就能帮上大忙:

```rust
enum Websocket {
  Tcp(Websocket<TcpStream>),
  Tls(Websocket<native_tls::TlsStream<TcpStream>>),
}
```

## Option<T>处理空值

工程中存在某个值可能有可能无的情况, 此时就用到`Option<T>`

### 定义

`Option<T>`的定义

```rust
enum Option<T> {
    Some(T),
    None,
}
```

### 变量绑定

若赋值`None`的变量之前为确定类型需要手动绑定类型, 或者说变量初始化为`None`需要手动制定类型

```rust
let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None; // 赋值None; 若之前未绑定过类型要指定类型
```

### 为什么要引入这套概念来处理空值

简而言之, 因为 `Option<T>` 和 `T`（这里 T 可以是任何类型）是不同的类型;

这两个类型不一致又有什么意义呢? 意味着无法运算; 也就意味着空值无法与任何普通类型进行运算;

也就不需要做空值检测(其实是强制让写程序的人做了)

### Some(T)怎么参与运算

> 见专项

# 数组

## 长度固定的array

array大小长度固定, 存在栈上

```rust
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let s: [&str; 12] = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
}
```

支持隐式/显示注明类型, 所有元素类型一致, (也可以说是数组的类型吧)

```rust
let a = [3; 5]; // 初始化数组为五个3
```

批量初始化重复值, 注意这里是通过深拷贝了5个3, 如果是存储在Heap上的数据类型不支持深拷贝, 也就不支持这种初始化方式

那怎么做呢? 见[跳转]()

### 访问数组

通过索引访问, 索引从0开始计数

```rust
fn main() {
    let a = [9, 8, 7, 6, 5];
    let first = a[0];
    let second = a[1];
}
```

运行时越界访问会导致程序在错误处崩溃退出

代码中越界访问会panic

### 批量初始化所有权类型数组

```rust
// 写法一: 一个一个写
let array1 = [String::from("rust is good!"),String::from("rust is good!"),String::from("rust is good!")];
// 写法二: 使用std::array::from_fn
let array2: [String; 8] = std::array::from_fn(|_i| String::from("rust is good!"));
println!("{:#?}", array2);
```

### 数组切片

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
let slice: &[i32] = &a[1..3];
```

## 动态数组

### 创建

无数据无类型的话编译时会报错, 要么手动指明类型, 要么压入数据

```rust
let v: Vec<i32> = Vec::new();

let a = Vec::new();
a.push(1);
```

使用宏 `vec!` 来创建数组, 有数据可以不指定类型, 无数据需要指定类型

```rust
let v = vec![1, 2, 3];
let empty_i32: Vec<i32> = vec![];
let empty_u8 = vec![] as Vec<u8>;
```

### 增删

```rust
let v = vec![1, 2, 3];
v.push[4];
```

### 访问

```rust
let v = vec![1, 2, 3];
let a: &i32 = &v[2];
let b: Option<i32> = v.get(3);
match b {
    Some(args) => println!("找到值: {}", args),
    None => println!("索引越界!"),
}
```

`get()` 方法存在的意义是处理越界访问问题, 我们写代码时可以用下标访问;

但如果某个程序涉及用户输入值, 我们就需要考虑越界访问问题, 谁也不知道用户会输入什么
