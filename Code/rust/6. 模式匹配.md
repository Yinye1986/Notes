# match

## 示例

`match`需要列出所有的可能, 未列出的用`_`代替

```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => {
            println!("South or North");
        },
        _ => println!("West"),
    };
}
```

```rust
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, _) => {
                println!("change color into '(r:{}, g:{}, b:0)', 'b' has been ignored",
                    r, g,
                );
            }
        }
    }
}
```

## 用match赋值

`match`是一个表达式, 有返回值, 可用于赋值

如果对应模式的最后一行不为表达式会隐式返回单元类型

```rust
enum IpAddr {
   Ipv4,
   Ipv6
}

fn main() {
    let ip1 = IpAddr::Ipv6;
    let ip_str = match ip1 {
        IpAddr::Ipv4 => "127.0.0.1",
        _ => "::1",
    };

    println!("{}", ip_str);
}
```

## 穷尽匹配

`u8`可能的值有0~255, 我们只用到1,3,5,7, 就可以用`_`给其他情况返回`()`

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    5 => println!("five"),
    7 => println!("seven"),
    _ => (),
}
```

# if let

有时会遇到只有一个模式的值需要被处理，其它值直接忽略的场景，如果用 match 来处理就要写成下面这样：

```rust
let v = Some(3u8);
match v {
    Some(3) => println!("three"),
    _ => (),
}
```

我们只想要对 `Some(3)` 模式进行匹配, 不想处理任何其他 `Some<u8>` 值或 `None` 值

但是为了满足match表达式穷尽性的要求, 写代码时必须在处理完这唯一的成员后加上 `_ => ()` , 这样会增加不少无用的代码

我们完全可以用 if let 的方式来实现:

```rust
if let Some(3) = v {
    println!("three");
}
```

这里的"条件语句"怎么是反着写的?

不是条件语句, 也没有什么反着写; 实际含义: 如果变量 `v` 的内容与右侧的模式 `Some(3)` 相匹配, 则执行代码块

当只要匹配一个条件, 且忽略其他条件时就用 `if let` , 否则都用 `match`

# 变量遮蔽

```rust
fn main() {
   let age = Some(30);
   println!("在匹配前，age是{:?}",age);
   if let Some(age) = age { // 注意!!! 不是Some(30)而是Some(age)
       println!("匹配出来的age是{}",age);
   }

   println!("在匹配后，age是{:?}",age);
}
```
在`if let`作用域中, age被
